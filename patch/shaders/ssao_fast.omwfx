sampler_2d noise {
    source = "shaders/textures/poisson_nrm.dds";
    mag_filter = nearest;
    min_filter = nearest;
    wrap_s = repeat;
    wrap_t = repeat;
}

uniform_float max_ray_radius {
    default = 1.0;
    min = 1.0;
    max = 100.0;
    step = 1.0;
    description = "Max ray radius, world units.";
}

uniform_float multiplier {
    default = 1.8;
    min = 0.1;
    max = 10.0;
    step = 0.1;
    description = "Overall strength. 1.0 is the correct physical value.";
}

uniform_float occlusion_falloff {
    default = 20.0;
    min = 0.0;
    max = 100.0;
    step = 1.0;
    description = "Occlusion falloff. More means less depth precision, and more strength.";
}

uniform_float blur_falloff {
    default = 0.1;
    min = 0.0;
    max = 1.0;
    step = 0.01;
    description = "Blur depth falloff, more means a larger depth range is blurred.";
}

uniform_float blur_radius {
    default = 5.0;
    min = 0.0;
    max = 100.0;
    step = 1.0;
    description = "Blur radius in pixels";
}

shared {
    const float sky = 1000000.0;

    float getLinearDepth(in vec2 tex)
    {
        float d = omw_GetDepth(tex);
        float ndc = d * 2.0 - 1.0;

        return omw.near * omw.far / (omw.far + ndc * (omw.near - omw.far));
    }

    vec2 fromView(vec3 view, vec2 t)
    {
        return vec2(view.xy / t / view.z + 0.5);
    }

    vec3 toView(vec2 tex, vec2 t)
    {
        float depth = min(getLinearDepth(tex), sky);
        vec2 xy = (tex - 0.5) * depth * t;
        return vec3(xy, depth);
    }

    float luminance(vec3 rgb)
    {
        // Algorithm from Chapter 10 of Graphics Shaders. 
        const vec3 W = vec3(0.2125, 0.7154, 0.0721);
        return dot(rgb, W);
    }
}

fragment ssao {
    omw_In vec2 omw_TexCoord;

    vec2 pack2(float f)
    {
        return vec2(f, fract(f * 255.0 - 0.5));
    }

    void main()
    {
        const float depth_scale = 10000.0;
        vec2 rcpResolution = vec2(1.0 / omw.resolution);
        vec2 t  = (2.0 * tan(radians(omw.fov * 0.5)) * vec2(1.0, rcpResolution.x / rcpResolution.y));

        vec3 pos = toView(omw_TexCoord, t);

//busted?
/* 
        float xylength = sqrt(1.0 - omw.eyeVec.z * omw.eyeVec.z);
        float water = pos.z * omw.eyeVec.z - pos.y * xylength + omw.eyePos.z;

        if(pos.z <= 0.0 || pos.z > sky || (water - omw.waterHeight) < 0.0)
        {
            omw_FragColor = vec4(0, 0, 0, 1);
            return;
        }
*/
        vec3 left = pos - toView(omw_TexCoord + rcpResolution * vec2(-1, 0), t);
        vec3 right = toView(omw_TexCoord + rcpResolution * vec2(1, 0), t) - pos;
        vec3 up = pos - toView(omw_TexCoord + rcpResolution * vec2(0, -1), t);
        vec3 down = toView(omw_TexCoord + rcpResolution * vec2(0, 1), t) - pos;

        vec3 dx = length(left) < length(right) ? left : right;
        vec3 dy = length(up) < length(down) ? up : down;

        vec3 normal = normalize(cross(dy, dx));
        dy = normalize(cross(dx, normal));
        dx = normalize(dx);

        vec3 rnd = texture2D(noise, omw_TexCoord / rcpResolution / 8.0).xyz * 2.0 - 1.0;

        float AO = 0.0, amount = 0.0;
        vec3 ray, occ;
        float diff, weight;

        ray = reflect(vec3(0.00762, -0.01247, 0.03311) * max_ray_radius, rnd);
        ray *= sign(ray.z);
        ray = dx * ray.x + dy * ray.y + normal * ray.z;
        weight = dot(normalize(ray), normal);
        occ = toView(fromView(pos + ray, t), t);
        diff = (pos.z + ray.z) - 1.00025 * occ.z;
        amount += weight;
        AO += weight * step(0.0, diff) * exp2(-diff / occlusion_falloff);

        ray = reflect(vec3(-0.61057, 0.20510, 0.58876) * max_ray_radius, rnd);
        ray *= sign(ray.z);
        ray = dx * ray.x + dy * ray.y + normal * ray.z;
        weight = dot(normalize(ray), normal);
        occ = toView(fromView(pos + ray, t), t);
        diff = (pos.z + ray.z) - 1.00025 * occ.z;
        amount += weight;
        AO += weight * step(0.0, diff) * exp2(-diff / occlusion_falloff);

        ray = reflect(vec3(0.55319, 0.67960, -0.19194) * max_ray_radius, rnd);
        ray *= sign(ray.z);
        ray = dx * ray.x + dy * ray.y + normal * ray.z;
        weight = dot(normalize(ray), normal);
        occ = toView(fromView(pos + ray, t), t);
        diff = (pos.z + ray.z) - 1.00025 * occ.z;
        amount += weight;
        AO += weight * step(0.0, diff) * exp2(-diff / occlusion_falloff);

        ray = reflect(vec3(-0.43533, 0.62404, 0.45133) * max_ray_radius, rnd);
        ray *= sign(ray.z);
        ray = dx * ray.x + dy * ray.y + normal * ray.z;
        weight = dot(normalize(ray), normal);
        occ = toView(fromView(pos + ray, t), t);
        diff = (pos.z + ray.z) - 1.00025 * occ.z;
        amount += weight;
        AO += weight * step(0.0, diff) * exp2(-diff / occlusion_falloff);

        ray = reflect(vec3(-0.02386, -0.03104, 0.01502) * max_ray_radius, rnd);
        ray *= sign(ray.z);
        ray = dx * ray.x + dy * ray.y + normal * ray.z;
        weight = dot(normalize(ray), normal);
        occ = toView(fromView(pos + ray, t), t);
        diff = (pos.z + ray.z) - 1.00025 * occ.z;
        amount += weight;
        AO += weight * step(0.0, diff) * exp2(-diff / occlusion_falloff);

        ray = reflect(vec3(-0.20990, 0.10082, 0.03849) * max_ray_radius, rnd);
        ray *= sign(ray.z);
        ray = dx * ray.x + dy * ray.y + normal * ray.z;
        weight = dot(normalize(ray), normal);
        occ = toView(fromView(pos + ray, t), t);
        diff = (pos.z + ray.z) - 1.00025 * occ.z;
        amount += weight;
        AO += weight * step(0.0, diff) * exp2(-diff / occlusion_falloff);

        ray = reflect(vec3(0.06331, -0.17620, -0.31359) * max_ray_radius, rnd);
        ray *= sign(ray.z);
        ray = dx * ray.x + dy * ray.y + normal * ray.z;
        weight = dot(normalize(ray), normal);
        occ = toView(fromView(pos + ray, t), t);
        diff = (pos.z + ray.z) - 1.00025 * occ.z;
        amount += weight;
        AO += weight * step(0.0, diff) * exp2(-diff / occlusion_falloff);

        ray = reflect(vec3(-0.12261, 0.00720, -0.12465) * max_ray_radius, rnd);
        ray *= sign(ray.z);
        ray = dx * ray.x + dy * ray.y + normal * ray.z;
        weight = dot(normalize(ray), normal);
        occ = toView(fromView(pos + ray, t), t);
        diff = (pos.z + ray.z) - 1.00025 * occ.z;
        amount += weight;
        AO += weight * step(0.0, diff) * exp2(-diff / occlusion_falloff);


        const float width = 0.3;
        const float sigma = 1.0;
        const float threshold =  0.7; // configurable
        AO *= pow((1.0 - (min(1.0,max(0.0,luminance(omw_GetLastShader(omw_TexCoord).rgb) - threshold + width))) / (2.0 * width)), sigma);

        omw_FragColor = vec4(AO / amount, pack2(pos.z / depth_scale), 1.0);
    }
}

fragment smartblur {
    omw_In vec2 omw_TexCoord;

    float unpack2(vec2 f)
    {
        return f.x + ((f.y - 0.5) / 255.0);
    }

    void main()
    {
        vec4 data = omw_GetLastPass(omw_TexCoord); //FIXME: mirror
        float total = data.r;
        float depth = unpack2(data.gb);
        float rev = blur_radius * (2.0*data.a - 1.0);
        float amount = 1.0;

        vec2 s_uv;
        vec3 s_data;
        float s_depth, weight;
        vec2 rcpResolution = vec2(1.0 / omw.resolution);

        s_uv = omw_TexCoord + rcpResolution * vec2(-0.695914,0.457137) * rev;
        s_data = omw_GetLastPass(s_uv).rgb; //FIXME: mirror
        s_depth = unpack2(s_data.gb);
        weight = exp2(-abs(depth - s_depth) / depth / blur_falloff);
        amount += weight;
        total += s_data.r * weight;

        s_uv = omw_TexCoord + rcpResolution * vec2(-0.203345,0.620716) * rev;
        s_data = omw_GetLastPass(s_uv).rgb; //FIXME: mirror
        s_depth = unpack2(s_data.gb);
        weight = exp2(-abs(depth - s_depth) / depth / blur_falloff);
        amount += weight;
        total += s_data.r * weight;

        s_uv = omw_TexCoord + rcpResolution * vec2(0.96234,-0.194983) * rev;
        s_data = omw_GetLastPass(s_uv).rgb; //FIXME: mirror
        s_depth = unpack2(s_data.gb);
        weight = exp2(-abs(depth - s_depth) / depth / blur_falloff);
        amount += weight;
        total += s_data.r * weight;

        s_uv = omw_TexCoord + rcpResolution * vec2(0.473434,-0.480026) * rev;
        s_data = omw_GetLastPass(s_uv).rgb; //FIXME: mirror
        s_depth = unpack2(s_data.gb);
        weight = exp2(-abs(depth - s_depth) / depth / blur_falloff);
        amount += weight;
        total += s_data.r * weight;

        s_uv = omw_TexCoord + rcpResolution * vec2(0.507431,0.064425) * rev;
        s_data = omw_GetLastPass(s_uv).rgb; //FIXME: mirror
        s_depth = unpack2(s_data.gb);
        weight = exp2(-abs(depth - s_depth) / depth / blur_falloff);
        amount += weight;
        total += s_data.r * weight;

        s_uv = omw_TexCoord + rcpResolution * vec2(0.89642,0.412458) * rev;
        s_data = omw_GetLastPass(s_uv).rgb; //FIXME: mirror
        s_depth = unpack2(s_data.gb);
        weight = exp2(-abs(depth - s_depth) / depth / blur_falloff);
        amount += weight;
        total += s_data.r * weight;

        s_uv = omw_TexCoord + rcpResolution * vec2(-0.32194,-0.932615) * rev;
        s_data = omw_GetLastPass(s_uv).rgb; //FIXME: mirror
        s_depth = unpack2(s_data.gb);
        weight = exp2(-abs(depth - s_depth) / depth / blur_falloff);
        amount += weight;
        total += s_data.r * weight;

        s_uv = omw_TexCoord + rcpResolution * vec2(-0.791559,-0.59771) * rev;
        s_data = omw_GetLastPass(s_uv).rgb; //FIXME: mirror
        s_depth = unpack2(s_data.gb);
        weight = exp2(-abs(depth - s_depth) / depth / blur_falloff);
        amount += weight;
        total += s_data.r * weight;

        omw_FragColor = vec4(total / amount, data.gb, 1.0 - data.a);
    }
}

fragment combine {
    omw_In vec2 omw_TexCoord;

    void main()
    {
        vec2 rcpResolution = vec2(1.0 / omw.resolution);
        vec2 t  = (2.0 * tan(radians(omw.fov * 0.5)) * vec2(1.0, rcpResolution.x / rcpResolution.y));

        float dist = length(toView(omw_TexCoord, t));
        float fog = clamp((omw.fogFar - dist) / (omw.fogFar - omw.fogNear), 0.0, 1.0);
        float final = fog * multiplier * omw_GetLastPass(omw_TexCoord).r;
        vec3 result = mix(omw_GetLastShader(omw_TexCoord).rgb, omw.fogColor.rgb * (1.0-fog), final);

        omw_FragColor = vec4(result, 1);
    }
}

technique {
    passes = ssao, smartblur, smartblur, combine;
    description = "SSAO, fast";
    author = "Knu";
    version = "1.0";
}
